{"version":3,"sources":["components/Toolbar.jsx","ShortcutsModule.js","components/Editor.jsx","App.js","serviceWorker.js","index.js"],"names":["toolbarBtuttons","label","className","icon","Toolbar","React","forwardRef","props","ref","map","i","key","QwilShortcuts","quill","matches","name","pattern","action","text","selection","lineStart","match","exec","annotatedText","matchedText","startIndex","index","range","length","formatInsideMatch","getFormat","deleteText","insertText","code","format","skipPaste","matchedTextStart","indexOf","currentFormat","getSelection","setTimeout","setSelection","s","formatLine","getText","bold","italic","strike","handleChange","this","bind","on","onChange","isPaste","changeHandler","call","getLine","line","offset","domNode","textContent","isValid","tagName","_this","delta","oldContents","source","ops","hasOwnProperty","regex","RegExp","insert","test","Editor","editorRef","useRef","Quill","import","register","useEffect","current","modules","toolbar","container","keyboard","bindings","shiftEnter","shiftKey","handler","insertEmbed","backspace","collapsed","prefix","formatText","removeFormat","qwilShortcuts","placeholder","maxLength","App","toolbarRef","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.bc39c9ae.chunk.js","sourcesContent":["import React from \"react\";\n\nconst toolbarBtuttons = [\n  {\n    label: \"BOLD\",\n    className: \"ql-bold toolbar-btn\",\n    icon: \"fas fa-bold\"\n  },\n  {\n    label: \"ITALIC\",\n    className: \"ql-italic toolbar-btn\",\n    icon: \"fas fa-italic\"\n  },\n  {\n    label: \"STRIKE\",\n    className: \"ql-strike toolbar-btn\",\n    icon: \"fas fa-strikethrough\"\n  },\n  {\n    label: \"code\",\n    className: \"ql-code toolbar-btn\",\n    icon: \"fas fa-code\"\n  },\n  {\n    label: \"CODE-BLOCK\",\n    className: \"ql-code-block toolbar-btn\",\n    icon: \"far fa-file-code\"\n  }\n];\n\nconst Toolbar = React.forwardRef(function (props, ref) {\n  return (\n    <div ref={ref}>\n      {toolbarBtuttons.map(({ label, className, icon }, i) => {\n        return (\n          <button key={i} className={`${className}`}>\n            {icon ? <i className={icon}></i> : label}\n          </button>\n        );\n      })}\n    </div>\n  );\n});\n\nexport default Toolbar;\n","class QwilShortcuts {\n  constructor(quill) {\n    this.quill = quill;\n    this.quill.on(\"text-change\", this.onChange(this));\n  }\n\n  matches = [\n    {\n      name: \"code\",\n      pattern: /(?:`){1}([^`]+)(?:`){1}/g,\n      action: (text, selection, pattern, lineStart) => {\n        let match = pattern.exec(text);\n        const annotatedText = match[0];\n        const matchedText = match[1];\n        const startIndex = lineStart + match.index;\n        const range = { index: startIndex + 1, length: matchedText.length };\n        const formatInsideMatch = this.quill.getFormat(range);\n\n        this.quill.deleteText(startIndex, annotatedText.length, \"silent\");\n        this.quill.insertText(\n          startIndex,\n          matchedText,\n          { ...formatInsideMatch, code: true },\n          \"silent\"\n        );\n        this.quill.format(\"code\", false);\n      }\n    },\n    {\n      name: \"code-block\",\n      pattern: /`{3}(.*)(`{3})?/g,\n      skipPaste: true,\n      action: (text, selection, pattern, lineStart) => {\n        const matchedTextStart = text.indexOf(\"```\");\n        const currentFormat = this.quill.getFormat(matchedTextStart);\n\n        if (matchedTextStart > 0) {\n          if (\"code-block\" in currentFormat) {\n            return;\n          }\n          this.quill.deleteText(matchedTextStart, 3);\n\n          const selection = this.quill.getSelection();\n          this.quill.insertText(selection.index, \"\\n\");\n          setTimeout(() => {\n            this.quill.setSelection({\n              index: selection.index + 1,\n              length: selection.length\n            });\n            const s = this.quill.getSelection();\n            this.quill.formatLine(\n              s.index,\n              this.quill.getText(s.index).length,\n              \"code-block\",\n              true\n            );\n          }, 0);\n        } else {\n          if (\"code-block\" in currentFormat) {\n            return;\n          }\n          this.quill.formatLine(\n            0,\n            this.quill.getText().length,\n            \"code-block\",\n            true\n          );\n          this.quill.deleteText(0, 3);\n        }\n      }\n    },\n    {\n      name: \"bold\",\n      pattern: /(?:\\*){2}([^*]+)(?:\\*){2}/g,\n      action: (text, selection, pattern, lineStart) => {\n        let match = pattern.exec(text);\n        const annotatedText = match[0];\n        const matchedText = match[1];\n        const startIndex = lineStart + match.index;\n\n        const range = {\n          index: startIndex + 2,\n          length: matchedText.length\n        };\n        const formatInsideMatch = this.quill.getFormat(range);\n        if (text.match(/^([*_ \\n]+)$/g)) return;\n        this.quill.deleteText(startIndex, annotatedText.length);\n        this.quill.insertText(startIndex, matchedText, {\n          ...formatInsideMatch,\n          bold: true\n        });\n        this.quill.format(\"bold\", false);\n      }\n    },\n    {\n      name: \"italic\",\n      pattern: /\\b(?:_){1}([^_]+)(?:_){1}/g,\n      action: (text, selection, pattern, lineStart) => {\n        let match = pattern.exec(text);\n        const annotatedText = match[0];\n        const matchedText = match[1];\n        const startIndex = lineStart + match.index;\n\n        const range = {\n          index: startIndex + 1,\n          length: matchedText.length\n        };\n        const formatInsideMatch = this.quill.getFormat(range);\n\n        if (text.match(/^([*_ \\n]+)$/g)) return;\n\n        this.quill.deleteText(startIndex, annotatedText.length);\n        this.quill.insertText(startIndex, matchedText, {\n          ...formatInsideMatch,\n          italic: true\n        });\n        this.quill.format(\"italic\", false);\n      }\n    },\n    {\n      name: \"strikethrough\",\n      pattern: /(?:~){2}([^~]+)(?:~){2}/g,\n      action: (text, selection, pattern, lineStart) => {\n        let match = pattern.exec(text);\n\n        const annotatedText = match[0];\n        const matchedText = match[1];\n        const startIndex = lineStart + match.index;\n        const range = {\n          index: startIndex + 2,\n          length: matchedText.length\n        };\n        const formatInsideMatch = this.quill.getFormat(range);\n        if (text.match(/^([*_ \\n]+)$/g)) return;\n\n        setTimeout(() => {\n          this.quill.deleteText(startIndex, annotatedText.length);\n          this.quill.insertText(startIndex, matchedText, {\n            ...formatInsideMatch,\n            strike: true\n          });\n          this.quill.format(\"strike\", false);\n        }, 0);\n      }\n    }\n  ];\n\n  handleChange(isPaste) {\n    this.changeHandler.call(this, isPaste);\n  }\n\n  changeHandler(isPaste) {\n    setTimeout(() => {\n      const selection = this.quill.getSelection();\n      if (!selection) return;\n\n      const [line, offset] = this.quill.getLine(selection.index);\n      const text = line.domNode.textContent + \" \";\n      const lineStart = selection.index - offset;\n\n      selection.length = selection.index++;\n\n      if (this.isValid(text)) {\n        for (let match of this.matches) {\n          const matchedText = text.match(match.pattern);\n          if (matchedText) {\n            if (isPaste) {\n              if (!match.skipPaste) {\n                match.action(text, selection, match.pattern, lineStart);\n              }\n            } else {\n              match.action(text, selection, match.pattern, lineStart);\n            }\n            return;\n          }\n        }\n      }\n    }, 0);\n  }\n\n  handleChange = this.handleChange.bind(this);\n\n  isValid(text, tagName) {\n    return typeof text !== \"undefined\" && text;\n  }\n\n  onChange(_this) {\n    return function (delta, oldContents, source) {\n      if (source === \"api\") {\n        return;\n      }\n      for (let i = 0; i < delta.ops.length; i++) {\n        if (delta.ops[i].hasOwnProperty(\"insert\")) {\n          const regex = new RegExp(/\\*|~|_|`/g);\n          const isPaste = delta.ops[i].insert.length > 1;\n          if (isPaste) {\n            return;\n          }\n\n          if (regex.test(delta.ops[i].insert)) {\n            _this.handleChange(isPaste);\n          }\n        }\n      }\n    };\n  }\n}\n\nexport default QwilShortcuts;\n","import React, { useRef } from \"react\";\nimport Quill from \"quill\";\nimport QwilShortcuts from \"../ShortcutsModule\";\nimport \"../quill.css\";\n\nfunction Editor(props) {\n  const editorRef = useRef();\n\n  // for inline code\n  const Code = Quill.import(\"formats/code\");\n  Code.className = \"markdown-code\";\n\n  //code-block custom class\n  const CodeBlock = Quill.import(\"formats/code-block\");\n  CodeBlock.className = \"markdown-pre\";\n\n  Quill.register(\"modules/qwilShortcuts\", QwilShortcuts);\n\n  React.useEffect(() => {\n    Editor.quill = new Quill(editorRef.current, {\n      modules: {\n        toolbar: {\n          container: props.toolbar.current\n        },\n        keyboard: {\n          bindings: {\n            shiftEnter: {\n              key: 13,\n              shiftKey: true,\n              handler: range => {\n                Editor.quill.insertEmbed(\n                  range.index,\n                  \"smartbreak\",\n                  true,\n                  \"user\"\n                );\n                Editor.quill.setSelection(range.index + 1, \"silent\");\n                return true;\n              }\n            },\n            backspace: {\n              key: \"backspace\",\n              collapsed: true,\n              format: [\"custom-pre\", \"code\", \"code-block\"],\n              handler: (range, offset) => {\n                if (!offset.prefix) {\n                  const currentFormat = Editor.quill.getFormat(range.index);\n                  if (currentFormat.code) {\n                    Editor.quill.formatText(range.index - 1, 2, {\n                      code: false\n                    });\n                  }\n\n                  if (currentFormat[\"code-block\"]) {\n                    const index =\n                      range.index > 0 ? range.index - 1 : range.index;\n                    Editor.quill.removeFormat(index, range.length, {\n                      \"code-block\": false\n                    });\n                  }\n                }\n                return true;\n              }\n            }\n          }\n        },\n        qwilShortcuts: {}\n      },\n      placeholder: \"Type your message here\"\n    });\n\n    Editor.quill.on(\"text-change\", () => {\n      if (props.maxLength) {\n        if (Editor.quill.getText().length > props.maxLength) {\n          Editor.quill.deleteText(\n            props.maxLength - 1,\n            Editor.quill.getText().length\n          );\n        }\n      }\n    });\n  });\n\n  return <div ref={editorRef}></div>;\n}\n\nexport default Editor;\n","import React, { useRef } from \"react\";\nimport \"./App.css\";\nimport Toolbar from \"./components/Toolbar\";\nimport Editor from \"./components/Editor\";\n\nfunction App() {\n  const toolbarRef = useRef();\n  return (\n    <div className=\"App\">\n      <div>\n        <Editor toolbar={toolbarRef} />\n        <Toolbar ref={toolbarRef} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}